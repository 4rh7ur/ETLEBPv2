---
title: "analise_algoritmo"
output: 
  html_document:
    number_sections: true
    toc: true
    toc_float: true
    
    


---

# Identificação dos Projetos das Bases Brutas nas Base Final
```{r, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(DBI)
library(dplyr)
library(ETLEBP)
library(RSQLite)
library(tidyverse)
# Importando os dados sqlite
filename <- here::here("data/DB_EIP/EIP_20210415.db")

con <- DBI::dbConnect(RSQLite::SQLite(),
                      ":memory:",
                      dbname = filename)

# Importando as tabelas do SQlite da INOVA-E
tbl_dm_agente_empresa <- dbReadTable(con,"dm_agente_empresa")
tbl_dm_categoria <- dbReadTable(con,"dm_categoria")
tbl_dm_formentador <- dbReadTable(con,"dm_formentador")
tbl_dm_mod_finan <- dbReadTable(con,"dm_mod_finan")
tbl_dm_nat_disp <- dbReadTable(con,"dm_nat_disp")
tbl_dm_projeto <- DBI::dbReadTable(con,"dm_projeto")
tbl_ft_dispendio <- dbReadTable(con,"ft_dispendio")

# Selecionando os atributos de interesse
dispendios_sel <- tbl_ft_dispendio %>%  select(id_item,id_formnt, vlr, id_cat2) %>%
                    group_by(id_item,id_formnt, id_cat2) %>% summarise(vlr = sum(vlr)) 

# Enriquecendo a tabela com as categorias de IEA
dispendios_sel <- left_join(dispendios_sel, tbl_dm_categoria,
          by = c("id_cat2" = "id"))
# Selecionando as categorias de interesse pós enriquecimento
dispendios_sel <- dispendios_sel %>% select(id_item,id_formnt, vlr,cat2)

# Dataset utilizado para a analise
dm_proj_dispendio <- merge(tbl_dm_projeto, dispendios_sel, all.x = T)  %>% unique()
```

O procedimento seguido para verificação dos casos foi: 1. Importamos as tabelas do SQLite; 2. Enriquecemos tabela de dispendios com os digitos 2 de classificação, e enriquecemos a tabela que detalha projetos com as categorias de IEA e a soma do financiamento do projeto; 3. Filtramos os dados por fomentador e seguimos a ánalise por fomentador dos dado; 4. Fazemos um fulljoin entre tabela que contém casos oriundos do SQLite e tabela com os projetos tratado; 5. Filtramos os dados com valores ausentes para os projetos de energia da base tratada; 5. Checamos se os casos que existem no SQLite não existem nos datasets originais da atual carga e se não existem no banco de dados utilizado em 2019.

## Aneel

Para os projetos da aneel temos o atributo id_item igual tanto na base de referência como na base bruta
```{r}
#Filtrando os casos do Fomentador alvo
dm_aneel <- dm_proj_dispendio %>% filter(id_formnt == 5)

#Importando os dataset tratado
aneel <- cria_base_intermediaria_aneel()

#Removendo o string identificador da base no atributo dos projetos
aneel <- aneel %>% mutate(id = str_remove(id, "ANEEL-"))

#Importando a base de dados bruta
origem_processos = here::here("data/SGPED_BI/PD Busca Textual.csv")

aneel_org  <- readr::read_delim(origem_processos,
                        ";", escape_double = FALSE, locale = readr::locale(encoding = "latin1"),
                        trim_ws = TRUE) %>%
    janitor::clean_names()
```

Ao enriquecermos o banco de dados observamos que existem 472 casos que só existem no SQLite e procuramos entender o por que esses dados não existem nos banco de dados tratado
```{r}
#juntamos todos os casos da base dm_aneel e aneel
comparacao <- tidylog::full_join(dm_aneel, aneel, suffix = c("_dm_aneel", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)
```

Dataset com os projetos de energia que só foram encontrados no SQLite.
```{r}
#criamos um dataset com todos os casos que não tem valores na base tratada
sobra_dm_aneel <- comparacao %>% filter(is.na(id))

reactable::reactable(sobra_dm_aneel)
```

Ao compararmos com os dados brutos da carga observamos que alguns dos casos faltantes aparecem 
```{r}
comparacao_org <- tidylog::inner_join(sobra_dm_aneel, aneel_org, 
                                     by = c("id_item" = "cod_proj"))
```
Seguem abaixo os casos identificados que estavam presentes no dataset bruto, observamos que os valores de custo total previsto e custo total realizado estavam com informações faltantes. Nosso script de tratamento exclue projetos de energia sem valores de financiamento.
```{r}
comparacao_org_sel <- comparacao_org %>% select(id_item,
                                                titulo,
                                                cat2,
                          custo_total_previsto,
                          custo_total_realizado,
                          situacao,
                          vlr)

reactable::reactable(comparacao_org_sel)
```


Decidimos então verificar se os casos existem no dataset usado na 1° carga do SQLite. E observamos que nenhum caso existe apenas apenas no SQLite.
```{r}
#checando com os valores dos dados do ebp1

aneel_ebp1 <- readr::read_delim(here::here("analise algoritmo/bases 1 versao ebp/5.ANEELpd.csv"), 
                         delim = ";", escape_double = FALSE, trim_ws = TRUE) %>%
  janitor::clean_names()

comparacao_ebp1 <- tidylog::inner_join(sobra_dm_aneel, aneel_ebp1,
                                       by = c("id_item" = "cod_proj")) %>%
                          select(id_item,
                          titulo,
                          cat2,
                          custo_total_previsto,
                          custo_total_realizado,
                          situacao,
                          vlr)

```
Quando verificado com os datasets utilizados na 1° versão da carga do ETL encontramos os valores de financiamento do projeto tais como  vistos no SQLite
```{r}
comparacao_ebp1 <- comparacao_ebp1 %>%
   mutate(custo_total_previsto          = as.numeric(stringr::str_replace_all(
                                           stringr::str_replace_all(custo_total_previsto, "[.$]", ""), "[,]", "." )),
          correto = custo_total_previsto == vlr ) 

reactable::reactable(comparacao_ebp1)
```


Por fim checamos se os casos que estão no SQLite também podem ser encontrados no dataset original
```{r}
# checando se os casos do SQlite se encontram  no dataset do ebp1
# todos os casos do SQLite estão no banco de dados usado no ebp1
check_aneel_id <- tidylog::full_join(dm_aneel, aneel_ebp1, suffix = c("_dm_aneel", "_base_ebp"),
                    by = c("id_item" = "cod_proj"), keep = TRUE)
```

## ANP

```{r}
#Filtrando os casos do Fomentador alvo
dm_anp <- dm_proj_dispendio %>% filter(id_formnt == 11)

#Importando os dataset tratado
anp <- cria_base_intermediaria_anp()

#Removendo o string identificador da base no atributo dos projetos
anp <- anp %>% mutate(id = str_remove(id, "ANP-"))

#Importando a base de dados bruta
origem_processos = origem_processos = here::here("data/ANP/projetos-rt-3-2015.csv")

anp_org <-  readr::read_delim(origem_processos,
                         ";", escape_double = FALSE, trim_ws = TRUE) %>%
              janitor::clean_names()

#juntamos todos os casos da base dm_anp e anp
#0 Matched Rows
comparacao_anp <- tidylog::full_join(dm_anp, anp, suffix = c("_dm_anp", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)

#criamos um dataset com todos os casos que não tem valores na base tratada
sobra_dm_anp <- comparacao_anp %>% filter(is.na(id))


```

Para os projetos da ANP só existe 1 projeto no SQLite dessa fonte. Portanto todos os casos vindos dessa carga são projetos novos e não seria possível encontrar correspondência entre os casos.

```{r}
#juntamos todos os casos da base dm_anp e anp
#0 Matched Rows
comparacao_anp <- tidylog::full_join(dm_anp, anp, suffix = c("_dm_anp", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)
```

Ao fazer o procedimento com os dados originais, encontramos o mesmo resultado.

```{r}
# comparando os casos que não foram encontrados do sqlite na base tratada
# com os casos que estão na base original
comparacao_anp_org <- tidylog::inner_join(sobra_dm_anp, anp_org, 
                                     by = c("id_item" = "no_anp"))

```

Só há um caso na ANP e esse caso não é retornado ao banco de dados utilizado na 1° versão do projeto.

```{r}
anp_ebp <- readr::read_delim(here::here("analise algoritmo/bases 1 versao ebp/4.anp.csv"), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE, 
    skip = 4) %>%  janitor::clean_names()

# comparando os casos que não foram encontrados do sqlite na base tratada
# com os casos usados na base original
comparacao_anp_ebp <- tidylog::inner_join(sobra_dm_anp, anp_ebp,
                    by = c("id_item" = "no_anp"), keep = TRUE)
```

Por fim checamos se os casos que estão no SQLite também podem ser encontrados no dataset original. Infelizmente não tivemos sucesso.

```{r}
#Só há um caso na ANP e esse caso não é retornado ao banco de dados utilizado na
#1° versão do projeto
check_anp_id <- tidylog::full_join(dm_anp, anp_ebp, suffix = c("_dm_aneel", "_base_ebp"),
                    by = c("id_item" = "no_anp"), keep = TRUE)
```


## BNDES

Para os projetos do BNDES temos 102 casos no SQLite. O caso do BNDES tem algumas especificidades, conforme veremos a seguir,  primeira é que não conseguimos recuperar alguns projetos do SQlite no dataset original, a outra é que houve uma alteração nos campos de identificação do projeto que não costam na base de dados utilizada para fazer a 1° carga do projeto.

Já que o ID dos projetos foi alterado, decidimos fazer a busca pelo título do projeto

```{r}
#Filtrando os casos do Fomentador alvo
#102 casos
dm_bndes <- dm_proj_dispendio %>% filter(id_formnt == 6)

#Importando os dataset tratado
bndes <- cria_base_intermediaria_bndes()

#Removendo o string de identificação da fonte do identificador do projeto
bndes <- bndes %>% mutate(id = str_remove(id, "BNDES-"))


#Importando dataset bruto
origem_processos = here::here("data/BNDES/naoautomaticas.xlsx")

bndes_org <- readxl::read_excel(origem_processos, skip = 4)%>%
           janitor::clean_names()

# Falha quando comparamos por id. 0 Matched Rows
# 102 linhas apenas em dm_bndes
comparacao_bndes_id <- tidylog::full_join(dm_bndes, bndes, suffix = c("_dm_bndes", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)

```

Ainda assim nós é retornado que existem 97 projetos apenas no SQLite que não podem ser encontrados na base tratada

```{r}
# 97 linhas apenas em dm_bndes
comparacao_bndes <- tidylog::full_join(dm_bndes, bndes, suffix = c("_dm_bndes", "_base_tratada"),
                    by = c("título" = "titulo_projeto"), keep = TRUE)

```
Os projetos que foram retornados podem ser vistos a seguir
```{r}
#dataset com todos os casos que existem no SQLite da inova-E 
#mas que não tem correspondência na base tratada
sobra_dm_bndes <-  comparacao_bndes %>% filter(is.na(titulo_projeto))

reactable::reactable(sobra_dm_bndes)
```

Ao fazermos a comparação com os dados originais do BNDES ainda assim não conseguimos fazer correspondência entre o título do projeto no SQLite com o título dos Projetos nos datasets originais.
```{r}
#utilizando a base bruta

comparacao_bndes_org_id <- tidylog::inner_join(sobra_dm_bndes, bndes_org, 
                                     by = c("id_item" = "numero_do_contrato"))

comparacao_bndes_org <- tidylog::inner_join(sobra_dm_bndes, bndes_org, 
                                     by = c("título" = "descricao_do_projeto"))



```
Ao fazermos uso dos dados que foram utilizados para fazer a primeira carga no projeto não conseguimos encontrar nenhuma correspondência, como pode ser visto abaixo.

```{r}
# fazendo uso dos dados que foram carregados na fase 1 do projeto

bndes_ebp <- read_delim(here::here("analise algoritmo/bases 1 versao ebp/6.bndes.csv"), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE, 
    skip = 4) %>% janitor::clean_names() %>% 
    mutate(numero_do_contrato = as.character(numero_do_contrato))

comparacao_bndes_ebp_id <- tidylog::inner_join(sobra_dm_bndes, bndes_ebp,
                                       by = c("id_item" = "numero_do_contrato"))

comparacao_bndes_ebp <- tidylog::inner_join(sobra_dm_bndes, bndes_ebp,
                                       by = c("título" = "descricao_do_projeto")) %>%
                          select(título,
                          id_item,
                          numero_do_contrato,
                          cat2,
                          valor_contratado_r,
                          valor_desembolsado_r,
                          situacao_do_contrato,
                          vlr)
```


Ao executar a comparação entre os casos do BNDES no SQLite com os dados usados para fazer a 1° carga não conseguimos encontrar correspondência ao usar o atributo id_item, que mede o código identificador do projeto na fonte
```{r}

check_bndes_id <- tidylog::full_join(dm_bndes, bndes_ebp, suffix = c("_dm_bndes", "_base_ebp"),
                    by = c("id_item" = "numero_do_contrato"), keep = TRUE)
```

Todavia ao fazer o mesmo procedimento utilizando o atributo título dos 102 projetos de energia, 97 não existem no dataset utilizado para fazer a 1° carga do EBP. Foram retornados 30 projetos incluindo projetos duplicados.
```{r}
#Dos 102 projetos encontrados no SQlite 97 não foram encontrados no banco de dados original

check_bndes <- tidylog::full_join(dm_bndes, bndes_ebp, suffix = c("_dm_bndes", "_base_ebp"),
                    by = c("título" = "descricao_do_projeto"), keep = TRUE)
```

Dataset om os casos encontrados no dataset usado na 1° versão do EBP
```{r}
reactable::reactable(check_bndes)
```

## CNEN
Já para a CNEN temos apenas um caso no SQLite, que é um caso que agrega os investimentos da CNEN no período. Esse caso agregado não pode ser encontrado nem na base tratada

```{r}
#Apenas 1 caso oriunda da CNEN
dm_cnen <- dm_proj_dispendio %>% filter(id_formnt == 12)

cnen <- cria_base_intermediaria_cnen()

origem_processos = here::here("data/CNEN/Projeto CNEN_Plataforma Inova-E.xlsx")

#importando base de dados bruta
cnen_org <- readxl::read_excel(origem_processos,
                     col_types = c("text", "text", "text",
                                   "text", "date", "date", "text", "numeric",
                                   "text", "text", "text", "text", "text",
                                   "text", "text", "text", "text", "text")) %>%
    janitor::clean_names() %>%
    dplyr::slice(-c(1,2,3))

#Checando os projetos no banco de dados tratado

#nenhum caso encontrado pelo id
comparacao_cnen_id <- tidylog::full_join(dm_cnen, cnen, suffix = c("_dm_cnen", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)
```
Nem na base original
```{r}

#nenhum caso encontrado pelo título do projeto
comparacao_cnen <- tidylog::full_join(dm_cnen, cnen, suffix = c("_dm_cnen", "_base_tratada"),
                    by = c("título" = "titulo_projeto"), keep = TRUE)

sobra_dm_cnen <- comparacao_cnen %>% filter(is.na(id))


```

Para a CNEN não foi encontrada a base de dados utilizada na 1° versão do projeto.
## CNPQ

```{r}

```


## FINEP

Temos 32 casos no SQLite oriundos da FINEP.
```{r}
dm_finep <- dm_proj_dispendio %>% filter(id_formnt == 7)

finep <- cria_base_intermediaria_finep()

finep <- finep %>% tibble() %>%  mutate(id = str_remove(id, "FINEP-"))

#importando base de dados bruta
origem_processos = here::here("data/FINEP/14_09_2021_Liberacoes.ods")

finep_org <- readODS::read_ods(path = origem_processos,
                    skip = 4,
                    sheet = 1)

names(finep_org)<-finep_org[1,]

finep_org <- finep_org %>% janitor::clean_names()%>% dplyr::slice(-1)
```

Desses 32 casos apenas 2 não foram encontrados no banco de dados tratado, quando utilizamos o atributo id do projeto
```{r}
# 2 linhas apenas em dm_finep
# 95 Matched rows
comparacao_finep_id <- tidylog::full_join(dm_finep, finep, suffix = c("_dm_finep", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)
```

Já quando usamos o título do projeto encontramos 3 casos que existem apenas no SQLite.
```{r}
# 3 linhas apenas em dm_finep
#93 matched rows
comparacao_finep <- tidylog::full_join(dm_finep, finep, suffix = c("_dm_finep", "_base_tratada"),
                    by = c("título" = "titulo_projeto"), keep = TRUE)
```

Decidimos checar a existência dos casos no dataset original.
Todos os casos que não existem no dataset tratado existem no dataset original.
```{r}
#dataset com todos os casos que existem no SQLite da inova-E 
#mas que não tem correspondência na base tratada
sobra_dm_finep <-  comparacao_finep_id %>% filter(is.na(id))

#utilizando a base bruta
#8 matched rows
comparacao_finep_org_id <- tidylog::inner_join(sobra_dm_finep, finep_org, 
                                     by = c("id_item" = "contrato"))%>%
                          select(título,
                          id_item,
                          cat2,
                          valor_finep,
                          status,
                          vlr)
```
Seguem os projetos que não foram identificados no banco de dados tratado.
```{r}
reactable::reactable(sobra_dm_finep)
```

Quando utilizamos o atributo título do projeto também nos é retornado os mesmo 8 projetos.
```{r}
#8 matched rows
comparacao_finep_org <- tidylog::inner_join(sobra_dm_finep, finep_org, 
                                     by = c("título" = "titulo")) %>% 
                        select(título,
                          id_item,
                          cat2,
                          valor_finep,
                          status,
                          vlr)
```
A saber seguem os projetos que não foram identificados no dataset tratado mas existem no dataset original.

```{r}
reactable::reactable(comparacao_finep_org)
```

Quando verificamos com o dataset utilizado na 1° carga do SQLite também encontramos esses casos .

```{r}
#fazendo a analise com os casos importados na 1° carga do SQLite

finep_ebp <- read_delim(here::here("analise algoritmo/bases 1 versao ebp/2.FINEP.csv"), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE, 
    skip = 5) %>% janitor::clean_names()

#8 matched rows
comparacao_finep_ebp_id <- tidylog::inner_join(sobra_dm_finep, finep_ebp, 
                                     by = c("id_item" = "contrato"))%>%
                          select(título,
                          id_item,
                          cat2,
                          valor_finep,
                          status,
                          vlr)
```


```{r}
#8 matched rows
comparacao_finep_ebp <- tidylog::inner_join(sobra_dm_finep, finep_ebp, 
                                     by = c("título" = "titulo")) %>% 
                        select(título,
                          id_item,
                          cat2,
                          valor_finep,
                          status,
                          vlr)
```

Projetos de Energia encontrados na base original
```{r}
reactable::reactable(comparacao_finep_ebp)
```

```{r}
#todos os 32 projetos de energia encontrados no SQLite tem retorno no banco de dados original
check_finep <- tidylog::full_join(dm_finep, finep_ebp, suffix = c("_dm_bndes", "_base_ebp"),
                    by = c("id_item" = "contrato"), keep = TRUE)

```
Para o caso foram encontrados 2 projetos de energia que não foram encontrados devemos investigar o código do tratamento, afim de identificar o porquê dos casos serem excluídos.

## FAPESP
Para o caso da FAPESP temos 32 projetos de energia no SQLite
```{r}
dm_fapesp <- dm_proj_dispendio %>% filter(id_formnt == 7)

fapesp <- cria_base_intermediaria_fapesp()

fapesp <- fapesp %>% tibble() %>%  mutate(id = str_remove(id, "FAPESP-"))

#importando base de dados bruta
origem_processos = here::here("data/FAPESP/PROJETOS FAPESP SELECIONADOS INOVA-E - VALORES - 13 dez 2021.xlsx")

fapesp_org <- readxl::read_excel(origem_processos) %>%
    janitor::clean_names()

```

Ao compararmos os casos com o dataset bruto não encontramos nenhuma correspondência. 

```{r}
#juntamos todos os casos da base dm_fapesp e fapesp
#0 Matched Rows
# Nenhum caso encontrado no sqlite é encontrado na base tratada
comparacao_fapesp <- tidylog::full_join(dm_fapesp, fapesp, suffix = c("_dm_fapesp", "_base_tratada"),
                    by = c("id_item" = "id"), keep = TRUE)
```
Decidimos então fazer a comparação com os dados originais sem nenhum tratamento. Ainda assim não encontramos qualquer correspondência.

```{r}


#criamos um dataset com todos os casos que não tem valores na base tratada
sobra_dm_fapesp <- comparacao_fapesp %>% filter(is.na(id))

# comparando os casos que não foram encontrados do sqlite na base tratada
# com os casos que estão na base original
comparacao_fapesp_org <- tidylog::inner_join(sobra_dm_fapesp, fapesp_org, 
                                     by = c("id_item" = "n_processo"))
```

Decidimos então comparar com o dataset utilizado para fazer a carga no SQLite na primeira versão do projeto

```{r}

#importando dataset utilizado no ebp
fapesp_ebp <- read_delim(here::here("analise algoritmo/bases 1 versao ebp/7.FAPESP_energia.csv"), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE) %>% janitor::clean_names()


# comparando os casos que não foram encontrados do sqlite na base tratada
# com os casos usados na base original
comparacao_anp_ebp <- tidylog::inner_join(sobra_dm_fapesp, fapesp_ebp,
                    by = c("id_item" = "n_processo"), keep = TRUE)

```

Ao checarmos se existe correspondência entre os casos do SQLite e os casos utilizados na primeira carga também não encontramos correspondência alguma. Seja por título de projeto seja por id do projeto
```{r}
# checando se os casos do SQlite se encontram  no dataset do ebp1
# nenhum caso encontrado pelo n° do projeto
check_fapesp_id <- tidylog::full_join(dm_fapesp, fapesp_ebp, suffix = c("_dm_fapesp", "_base_ebp"),
                    by = c("id_item" = "n_processo"), keep = TRUE)
```


```{r}
# nenhum caso encontrado pelo n° do projeto# nenhum caso encontrado pelo título
check_fapesp <- tidylog::full_join(dm_fapesp, fapesp_ebp, suffix = c("_dm_fapesp", "_base_ebp"),
                    by = c("título" = "titulo_portugues"), keep = TRUE)
```


# Validação Algoritmo

## Aneel

Consideramos que projetos classificados em mais de uma categoria de nivel 1 serão classificados na subseção 9


```{r}
comparacao_org <- comparacao_org %>% mutate(motor                         = tolower(stringi::stri_trans_general(paste(titulo,segmento,tema),
                                                                "Latin-ASCII")))
comparacao_org_sel <- comparacao_org %>% select(id_item,
                                                titulo,
                                                cat2,
                          custo_total_previsto,
                          custo_total_realizado,
                          situacao,
                          vlr, motor)

comparacao_org_sel <- dtc_categorias(df = comparacao_org_sel, processo = id_item,
               motor =motor) 

comparacao_org_sel <- comparacao_org_sel %>% 
  dplyr::mutate(categorias = dplyr::recode(categorias,
                                                        "character(0" = "nenhuma categoria encontrada"))

comparacao_org_sel2 <- comparacao_org_sel %>% rowwise() %>%
  mutate(categorias_split = str_split(categorias, pattern = ",")) %>%
  ungroup() %>% unnest(categorias_split_un =categorias_split) %>% 
  mutate(categorias_split_un = str_remove_all(categorias_split_un, '\\"')) %>%
  mutate(correto = categorias_split_un == cat2 ) %>% group_by(id_item) %>%
  summarise(correto = mean(correto))

grau_acerto <- mean(comparacao_org_sel2$correto)
```

 
